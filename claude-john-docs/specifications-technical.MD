# Number Warmer — Technical Specifications

## Architecture Overview

```
┌──────────────┐         JSON over network         ┌──────────────┐
│   CLIENT 1   │ ◄──────────────────────────────► │    SERVER     │
│  (browser)   │                                   │  (Node.js)   │
└──────────────┘                                   └──────┬───────┘
                                                          │
┌──────────────┐         JSON over network                │
│   CLIENT 2   │ ◄────────────────────────────────────────┘
│  (browser)   │   (human game only; AI game = 1 client)
└──────────────┘
```

- **Clients** are plain HTML/CSS/JS running in the browser
- **Server** generates mystery numbers, evaluates guesses, relays state
- **AI games** use only one client; the server calls the AI API on behalf of
  the AI player

---

## File Structure

```
online-02-numberWarmer/
├── client/
│   ├── lobby.html              # LOBBY screen
│   ├── humanhost-setup.html    # HUMANHOST-SETUP screen
│   ├── ai-setup.html           # AI-SETUP screen
│   ├── gameplay.html           # GAMEPLAY screen
│   ├── css/
│   │   ├── shared.css          # common styles (header, buttons, layout)
│   │   ├── lobby.css
│   │   ├── humanhost-setup.css
│   │   ├── ai-setup.css
│   │   └── gameplay.css
│   ├── js/
│   │   ├── shared.js           # common utilities (localStorage helpers, scaling)
│   │   ├── lobby.js
│   │   ├── humanhost-setup.js
│   │   ├── ai-setup.js
│   │   └── gameplay.js
│   └── assets/                 # images, icons, fonts
├── server/
│   └── (server code TBD)
├── design/                     # mockups and design docs
└── claude-john-docs/           # project documentation
```

Each screen is a **separate HTML file** with its own CSS and JS. This keeps
files small, focused, and easy to debug independently.

---

## Data Transport: Two Systems, One Shape

Data moves in two ways in this app, but uses the SAME JSON object shape:

### 1. Between screens on the same device → localStorage
### 2. Between client and server → JSON over the network

---

## The Game State Object

One JSON object represents the entire game state. It grows as the player
moves through screens. Here is the full shape with comments:

```js
{
    // --- Set by LOBBY ---
    playerName: "Tristan",       // the local player's name (max 8 chars)
    gameMode: "ai",              // "host" | "join" | "ai"

    // --- Set by HUMANHOST-SETUP (host games only) ---
    gameId: 666,                 // random 111-999 (host) or entered (joiner)
    trickyNumber: false,         // gameplay variant toggle

    // --- Set by AI-SETUP (ai games only) ---
    aiOpponent: "claude",        // "chatty" | "claude"

    // --- Set by SERVER when game starts ---
    mysteryNumber: 42,           // 1-100, generated by server (NEVER sent to client!)
    player1Name: "Tristan",      // host or local player
    player2Name: "Claude",       // 2nd human or AI name
    currentPlayer: "Tristan",    // whose turn it is
    turnNumber: 0,               // increments each guess
    gameStatus: "playing",       // "first-turn" | "playing" | "won"
    winner: null,                // name of winner when gameStatus = "won"

    // --- Updated each turn ---
    guesses: [
        // each guess is an object in this array
        {
            player: "Tristan",
            turn: 1,
            guess: 50,
            result: "First Guess"  // "First Guess" | "WARMER" | "COLDER"
        },
        {
            player: "Claude",
            turn: 2,
            guess: 75,
            result: "COLDER"
        },
        {
            player: "Tristan",
            turn: 3,
            guess: 30,
            result: "WARMER"
        }
    ]
}
```

**Important:** The `mysteryNumber` is NEVER included in state sent to clients.
Only the server knows it. Clients only see the guesses and WARMER/COLDER results.

---

## localStorage — How It Works

localStorage is a simple key-value store built into every browser. It persists
across page loads and even survives closing/reopening the browser.

### Basic API (4 methods, that's it)

```js
// WRITE a value (must be a string)
localStorage.setItem('key', 'value');

// READ a value (returns string, or null if not found)
const value = localStorage.getItem('key');

// DELETE a specific key
localStorage.removeItem('key');

// DELETE everything
localStorage.clear();
```

### Storing JSON Objects

Since localStorage only stores strings, we convert objects to/from JSON:

```js
// WRITE an object
const state = { playerName: "Tristan", gameMode: "ai" };
localStorage.setItem('gameState', JSON.stringify(state));

// READ it back
const state = JSON.parse(localStorage.getItem('gameState'));
console.log(state.playerName);  // "Tristan"
```

### Helper Functions (will go in shared.js)

```js
/**
 * Save the game state to localStorage.
 * Call this whenever the state changes on a screen before navigating away.
 */
function saveGameState(state) {
    localStorage.setItem('gameState', JSON.stringify(state));
}

/**
 * Load the game state from localStorage.
 * Call this when a screen first loads to pick up where the last screen left off.
 * Returns null if no state exists yet.
 */
function loadGameState() {
    const raw = localStorage.getItem('gameState');
    if (!raw) return null;
    return JSON.parse(raw);
}

/**
 * Clear the game state from localStorage.
 * Call this when returning to the lobby to start fresh.
 */
function clearGameState() {
    localStorage.removeItem('gameState');
}

/**
 * Save just the player name separately, so it persists across games.
 * This is the "cookie" behavior from the original design — but using
 * localStorage instead of actual cookies (simpler, no expiration worries).
 */
function savePlayerName(name) {
    localStorage.setItem('playerName', name);
}

/**
 * Load the saved player name, or return empty string if none saved.
 */
function loadPlayerName() {
    return localStorage.getItem('playerName') || '';
}
```

---

## Screen-to-Screen Data Flow (localStorage)

Here is exactly what happens at each screen transition:

### LOBBY → HUMANHOST-SETUP (player chose "Start a new game")
```js
// lobby.js — when START GAME is clicked
const state = {
    playerName: nameInput.value,
    gameMode: "host"
};
saveGameState(state);
savePlayerName(state.playerName);  // persist name for future visits
window.location.href = 'humanhost-setup.html';
```

### LOBBY → AI-SETUP (player chose "Play vs AI")
```js
// lobby.js — when START GAME is clicked
const state = {
    playerName: nameInput.value,
    gameMode: "ai"
};
saveGameState(state);
savePlayerName(state.playerName);
window.location.href = 'ai-setup.html';
```

### LOBBY → GAMEPLAY (player chose "Join a friend's game")
```js
// lobby.js — when START GAME is clicked (with valid gameID)
const state = {
    playerName: nameInput.value,
    gameMode: "join",
    gameId: parseInt(gameIdInput.value)
};
saveGameState(state);
savePlayerName(state.playerName);
window.location.href = 'gameplay.html';
```

### HUMANHOST-SETUP → GAMEPLAY
```js
// humanhost-setup.js — when START GAME is clicked
const state = loadGameState();           // read what lobby saved
state.gameId = generatedGameId;          // add the generated gameID
state.trickyNumber = trickyToggle;       // add tricky number choice
saveGameState(state);                    // save updated state
window.location.href = 'gameplay.html';
```

### AI-SETUP → GAMEPLAY
```js
// ai-setup.js — when START GAME is clicked
const state = loadGameState();           // read what lobby saved
state.aiOpponent = selectedAI;           // "chatty" or "claude"
saveGameState(state);                    // save updated state
window.location.href = 'gameplay.html';
```

### Any screen → Back to LOBBY
```js
// any screen — when Back to LOBBY is clicked
clearGameState();                        // wipe game state
window.location.href = 'lobby.html';
// Note: playerName is saved separately and survives this clear
```

---

## Client-to-Server Data Flow (JSON over network)

This is the GAMEPLAY phase. The client sends state to the server and receives
updated state back. The transport mechanism (HTTP fetch, WebSocket, etc.) is
TBD, but the JSON shape is the same gameState object.

### Client sends a guess to the server:
```js
// gameplay.js — when player submits a guess
const response = await fetch('/api/guess', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        gameId: state.gameId,
        playerName: state.playerName,
        guess: currentGuess
    })
});

const updatedState = await response.json();
// updatedState contains the new guesses array, currentPlayer, etc.
// Render the updated state to the screen
renderGameState(updatedState);
```

### Server evaluates a guess (pseudocode):
```js
// server — receives guess, evaluates it
function evaluateGuess(gameState, playerName, guess) {
    const previousGuess = gameState.guesses[gameState.guesses.length - 1];
    const distanceNew = Math.abs(guess - gameState.mysteryNumber);

    // Check for win
    if (guess === gameState.mysteryNumber) {
        gameState.gameStatus = "won";
        gameState.winner = playerName;
        gameState.guesses.push({
            player: playerName,
            turn: gameState.turnNumber + 1,
            guess: guess,
            result: "WIN"
        });
        return gameState;
    }

    // First guess of the game — no comparison possible
    if (gameState.guesses.length === 0) {
        gameState.guesses.push({
            player: playerName,
            turn: 1,
            guess: guess,
            result: "First Guess"
        });
    } else {
        // Compare to previous guess
        const distancePrev = Math.abs(previousGuess.guess - gameState.mysteryNumber);
        const result = (distanceNew < distancePrev) ? "WARMER" : "COLDER";

        gameState.guesses.push({
            player: playerName,
            turn: gameState.turnNumber + 1,
            guess: guess,
            result: result
        });
    }

    // Switch current player
    gameState.turnNumber += 1;
    gameState.currentPlayer = (playerName === gameState.player1Name)
        ? gameState.player2Name
        : gameState.player1Name;

    return gameState;  // send back to client(s) — WITHOUT mysteryNumber!
}
```

---

## Key Technical Decisions

| Decision | Choice | Why |
|----------|--------|-----|
| Screen architecture | Separate HTML files | Simplest to understand, debug, maintain |
| Between-screen data | localStorage | Browser's built-in key-value store, persists across page loads |
| Client-server data | JSON over network | Same state shape as localStorage, consistent pattern |
| Name persistence | localStorage (not cookies) | Simpler API, no expiration issues |
| Client validation | Yes, before sending | Instant feedback, don't waste server calls |
| Server validation | Yes, always | Server is authority, prevents cheating |
| Mystery number | Server-only | Never sent to clients, prevents cheating |
| Viewport units | dvh/svh (not vh) | Handles mobile browser chrome correctly |
| Design stage | 390x640 CSS px | Canonical mobile target per layout spec |

---

## Future Technical Considerations

- **Server technology:** Node.js with Express is a likely choice, but TBD
- **Real-time communication:** WebSockets may be better than HTTP polling for
  two-player human games (instant updates vs. repeated requests)
- **AI API integration:** Server calls ChatGPT or Claude API, formats the
  response as a guess, adds it to the game state
- **Tricky number:** Gameplay variant still needs to be defined
- **Deployment:** Expected on QNAP NAS or similar, domain numberWarmer.plutonic9.com
